From 0142b8a17755f9d51cb9bbaab12ec6af325f7f73 Mon Sep 17 00:00:00 2001
From: Stefano Pigozzi <stefano.pigozzi@gmail.com>
Date: Sat, 15 Oct 2011 18:44:00 +0200
Subject: [PATCH] added native mac osx backend to vo_gl

Added native Cocoa code to display an OpenGL window. Some of the code is
based on the OpenGL parts of vo_corevideo but I took the time to remove
old code based on Carbon.

There is autodetection in the configure script but you can use
--enable[disable]-cocoa to enable[disable] this.
---
 Makefile             |    1 +
 configure            |   37 ++++-
 libvo/cocoa_common.h |   20 ++
 libvo/cocoa_common.m |  523 ++++++++++++++++++++++++++++++++++++++++++++++++++
 libvo/gl_common.c    |   61 ++++++
 libvo/gl_common.h    |    1 +
 6 files changed, 642 insertions(+), 1 deletions(-)
 create mode 100644 libvo/cocoa_common.h
 create mode 100644 libvo/cocoa_common.m

diff --git a/Makefile b/Makefile
index 6013ca3..081a6fa 100644
--- a/Makefile
+++ b/Makefile
@@ -456,6 +456,7 @@ SRCS_MPLAYER-$(GGI)          += libvo/vo_ggi.c
 SRCS_MPLAYER-$(GIF)          += libvo/vo_gif89a.c
 SRCS_MPLAYER-$(GL)           += libvo/gl_common.c libvo/vo_gl.c \
                                 pnm_loader.c
+SRCS_MPLAYER-$(GL_COCOA)     += libvo/cocoa_common.m
 SRCS_MPLAYER-$(GL_SDL)       += libvo/sdl_common.c
 SRCS_MPLAYER-$(GL_WIN32)     += libvo/w32_common.c
 SRCS_MPLAYER-$(GL_X11)       += libvo/x11_common.c
diff --git a/configure b/configure
index 9221501..fb9249d 100755
--- a/configure
+++ b/configure
@@ -419,6 +419,7 @@ Video output:
   --disable-md5sum         disable md5sum video output [enable]
   --disable-yuv4mpeg       disable yuv4mpeg video output [enable]
   --disable-corevideo      disable CoreVideo video output [autodetect]
+  --disable-cocoa          disable Cocoa OpenGL backend [autodetect]
   --disable-quartz         disable Quartz video output [autodetect]
 
 Audio output:
@@ -680,6 +681,7 @@ _fontconfig=auto
 _qtx=auto
 _coreaudio=auto
 _corevideo=auto
+_cocoa=auto
 _quartz=auto
 quicktime=auto
 _macosx_finder=no
@@ -1115,6 +1117,8 @@ for ac_option do
   --disable-coreaudio) _coreaudio=no ;;
   --enable-corevideo) _corevideo=yes ;;
   --disable-corevideo) _corevideo=no ;;
+  --enable-cocoa) _cocoa=yes ;;
+  --disable-cocoa) _cocoa=no ;;
   --enable-quartz) _quartz=yes ;;
   --disable-quartz) _quartz=no ;;
   --enable-macosx-finder) _macosx_finder=yes ;;
@@ -4215,6 +4219,26 @@ else
 fi
 echores "$_corevideo"
 
+echocheck "Cocoa"
+if test "$_gl" = no ; then
+  # if _gl is not enabled there is no point to add potentially unused linker flags
+  _cocoa=no
+fi
+if test "$_cocoa" = auto ; then
+  cat > $TMPC <<EOF
+#include <CoreServices/CoreServices.h>
+#include <OpenGL/OpenGL.h>
+#include <QuartzCore/CoreVideo.h>
+int main(void) { return 0; }
+EOF
+  _cocoa=no
+  cc_check -framework Cocoa -framework QuartzCore -framework OpenGL && _cocoa=yes
+fi
+if test "$_cocoa" = yes ; then
+  libs_mplayer="$libs_mplayer -framework Cocoa -framework QuartzCore -framework OpenGL"
+fi
+echores "$_cocoa"
+
 fi #if darwin
 
 
@@ -4473,7 +4497,7 @@ echores "$_sdl"
 # conflicts between -lGL and -framework OpenGL
 echocheck "OpenGL"
 #Note: this test is run even with --enable-gl since we autodetect linker flags
-if (test "$_x11" = yes || test "$_sdl" = yes || win32) && test "$_gl" != no ; then
+if (test "$_x11" = yes || test "$_sdl" = yes || test "$_cocoa" = yes || win32) && test "$_gl" != no ; then
   cat > $TMPC << EOF
 #ifdef GL_WIN32
 #include <windows.h>
@@ -4521,6 +4545,10 @@ EOF
     _gl_win32=yes
     libs_mplayer="$libs_mplayer -lopengl32 -lgdi32"
   fi
+  if test "$_cocoa" = yes ; then
+    _gl=yes
+    _gl_cocoa=yes
+  fi
   # last so it can reuse any linker etc. flags detected before
   if test "$_sdl" = yes ; then
     if cc_check -DGL_SDL ||
@@ -4540,6 +4568,10 @@ fi
 if test "$_gl" = yes ; then
   def_gl='#define CONFIG_GL 1'
   res_comment="backends:"
+  if test "$_gl_cocoa" = yes ; then
+    def_gl_cocoa='#define CONFIG_GL_COCOA 1'
+    res_comment="$res_comment cocoa"
+  fi
   if test "$_gl_win32" = yes ; then
     def_gl_win32='#define CONFIG_GL_WIN32 1'
     res_comment="$res_comment win32"
@@ -4555,6 +4587,7 @@ if test "$_gl" = yes ; then
   vomodules="opengl $vomodules"
 else
   def_gl='#undef CONFIG_GL'
+  def_gl_cocoa='#undef CONFIG_GL_COCOA'
   def_gl_win32='#undef CONFIG_GL_WIN32'
   def_gl_x11='#undef CONFIG_GL_X11'
   def_gl_sdl='#undef CONFIG_GL_SDL'
@@ -6680,6 +6713,7 @@ FTP = $_ftp
 GIF = $_gif
 GGI = $_ggi
 GL = $_gl
+GL_COCOA = $_gl_cocoa
 GL_WIN32 = $_gl_win32
 GL_X11 = $_gl_x11
 GL_SDL = $_gl_sdl
@@ -7085,6 +7119,7 @@ $def_gif
 $def_gif_4
 $def_gif_tvt_hack
 $def_gl
+$def_gl_cocoa
 $def_gl_win32
 $def_gl_x11
 $def_gl_sdl
diff --git a/libvo/cocoa_common.h b/libvo/cocoa_common.h
new file mode 100644
index 0000000..25027e1
--- /dev/null
+++ b/libvo/cocoa_common.h
@@ -0,0 +1,20 @@
+#ifndef MPLAYER_COCOA_COMMON_H
+#define MPLAYER_COCOA_COMMON_H
+
+#include "gl_common.h"
+
+int vo_cocoa_init(struct vo *vo);
+void vo_cocoa_uninit(struct vo *vo);
+
+void vo_cocoa_update_xinerama_info(struct vo *vo);
+
+int vo_cocoa_change_attributes(struct MPGLContext *ctx);
+int vo_cocoa_create_window(struct MPGLContext *ctx, uint32_t d_width,
+                           uint32_t d_height, uint32_t flags,
+                           const char *title);
+
+void vo_cocoa_swap_buffers(void);
+int vo_cocoa_check_events(struct vo *vo);
+void vo_cocoa_fullscreen(struct vo *vo);
+
+#endif /* MPLAYER_COCOA_COMMON_H */
diff --git a/libvo/cocoa_common.m b/libvo/cocoa_common.m
new file mode 100644
index 0000000..1d307fa
--- /dev/null
+++ b/libvo/cocoa_common.m
@@ -0,0 +1,523 @@
+#import <Cocoa/Cocoa.h>
+#import <OpenGL/OpenGL.h>
+#import <QuartzCore/QuartzCore.h>
+#import <CoreServices/CoreServices.h> // for CGDisplayHideCursorfq
+#include "cocoa_common.h"
+#include "gl_common.h"
+
+#include "options.h"
+#include "video_out.h"
+#include "aspect.h"
+
+#include "mp_fifo.h"
+#include "talloc.h"
+
+#include "input/input.h"
+#include "input/keycodes.h"
+#include "osx_common.h"
+#include "mp_msg.h"
+
+#define NSLeftAlternateKeyMask (0x000020 | NSAlternateKeyMask)
+#define NSRightAlternateKeyMask (0x000040 | NSAlternateKeyMask)
+
+@interface GLMPlayerWindow : NSWindow <NSWindowDelegate> {
+    NSRect _tmp_frame;
+}
+@property (readwrite,assign) NSRect _tmp_frame;
+- (BOOL) canBecomeKeyWindow;
+- (BOOL) canBecomeMainWindow;
+- (void) fullscreen;
+- (void) mouseEvent:(NSEvent *)theEvent;
+- (void) mulSize:(float)multiplier;
+- (void) setContentSize:(NSSize)newSize keepCentered:(BOOL)keepCentered;
+@end
+
+@interface GLMPlayerOpenGLView : NSView
+@end
+
+struct vo_cocoa_state {
+    NSAutoreleasePool *pool;
+    GLMPlayerWindow *window;
+    NSOpenGLContext *glContext;
+
+    NSSize current_video_size;
+    NSSize previous_video_size;
+
+    NSRect screen_frame;
+    NSScreen *screen_handle;
+    NSArray *screen_array;
+
+    NSInteger windowed_mask;
+    NSInteger fullscreen_mask;
+
+    NSString *window_title;
+
+    int last_screensaver_update;
+
+    bool did_resize;
+};
+
+struct vo_cocoa_state *s;
+
+struct vo *l_vo;
+
+// local function definitions
+struct vo_cocoa_state *vo_cocoa_init_state(void);
+void update_screen_info(void);
+const char* title_from_vo_and_title(struct vo *vo, const char *title);
+void resize_window(struct vo *vo);
+void create_menu(void);
+
+struct vo_cocoa_state *vo_cocoa_init_state(void)
+{
+    struct vo_cocoa_state *s = talloc_ptrtype(NULL, s);
+    *s = (struct vo_cocoa_state){
+        .did_resize = NO,
+        .current_video_size = {0,0},
+        .previous_video_size = {0,0},
+        .windowed_mask = NSTitledWindowMask|NSClosableWindowMask|NSMiniaturizableWindowMask|NSResizableWindowMask,
+        .fullscreen_mask = NSBorderlessWindowMask,
+    };
+    return s;
+}
+
+int vo_cocoa_init(struct vo *vo)
+{
+    s = vo_cocoa_init_state();
+    s->pool = [[NSAutoreleasePool alloc] init];
+    NSApplicationLoad();
+    NSApp = [NSApplication sharedApplication];
+    [NSApp setActivationPolicy: NSApplicationActivationPolicyRegular];
+
+    return 1;
+}
+
+void vo_cocoa_uninit(struct vo *vo)
+{
+    CGDisplayShowCursor(kCGDirectMainDisplay);
+    [s->window release];
+    s->window = nil;
+    [s->glContext release];
+    s->glContext = nil;
+    [s->pool release];
+    s->pool = nil;
+
+    talloc_free(s);
+}
+
+void update_screen_info(void)
+{
+    s->screen_array = [NSScreen screens];
+    if(xinerama_screen >= (int)[s->screen_array count]) {
+        mp_msg(MSGT_VO, MSGL_INFO, "[cocoa] Device ID %d does not exist, falling back to main device\n", xinerama_screen);
+        xinerama_screen = -1;
+    }
+
+    if (xinerama_screen < 0) { // default behaviour
+        if (! (s->screen_handle = [s->window screen]) )
+            s->screen_handle = [s->screen_array objectAtIndex:0];
+    } else {
+        s->screen_handle = [s->screen_array objectAtIndex:(xinerama_screen)];
+    }
+
+    s->screen_frame = [s->screen_handle frame];
+}
+
+void vo_cocoa_update_xinerama_info(struct vo* vo)
+{
+    update_screen_info();
+    aspect_save_screenres(vo, s->screen_frame.size.width, s->screen_frame.size.height);
+}
+
+int vo_cocoa_change_attributes(struct MPGLContext *ctx)
+{
+    return SET_WINDOW_OK;
+}
+
+// this function exists because vf_vo.c calls config with title = "MPlayer"
+// and from the vo it will come down to the backend (ignoring --use-filename-title)
+const char* title_from_vo_and_title(struct vo *vo, const char *title)
+{
+    if(vo->opts->vo_wintitle){
+        return vo->opts->vo_wintitle;
+    } else if(title){
+        return title;
+    } else {
+        return "mplayer2";
+    }
+}
+
+void resize_window(struct vo *vo)
+{
+    vo->dwidth = [[s->window contentView] frame].size.width;
+    vo->dheight = [[s->window contentView] frame].size.height;
+    [s->glContext update];
+}
+
+int vo_cocoa_create_window(struct MPGLContext *ctx, uint32_t d_width,
+                           uint32_t d_height, uint32_t flags, const char *title)
+{
+    if(s->current_video_size.width > 0 || s->current_video_size.height > 0)
+        s->previous_video_size = s->current_video_size;
+    s->current_video_size = NSMakeSize(d_width, d_height);
+
+    if(!(s->window || s->glContext)) { // keep using the same window
+        s->window = [[GLMPlayerWindow alloc] initWithContentRect:NSMakeRect(0, 0, d_width, d_height)
+                                             styleMask:s->windowed_mask
+                                             backing:NSBackingStoreBuffered defer:NO];
+
+        GLMPlayerOpenGLView *glView = [[GLMPlayerOpenGLView alloc] initWithFrame:NSMakeRect(0, 0, 100, 100)];
+
+        NSOpenGLPixelFormatAttribute attrs[] = {
+            NSOpenGLPFADoubleBuffer, // double buffered
+            NSOpenGLPFADepthSize, (NSOpenGLPixelFormatAttribute)16, // 16 bit depth buffer
+            (NSOpenGLPixelFormatAttribute)0
+        };
+
+        NSOpenGLPixelFormat* pixelFormat = [[NSOpenGLPixelFormat alloc] initWithAttributes:attrs];
+        s->glContext = [[NSOpenGLContext alloc] initWithFormat:pixelFormat shareContext:nil];
+
+        create_menu();
+
+        [s->window setContentView:glView];
+        [glView release];
+        [s->window setAcceptsMouseMovedEvents:YES];
+        [s->glContext setView: glView];
+        [s->glContext makeCurrentContext];
+
+        [NSApp setDelegate: s->window];
+        [s->window setDelegate: s->window];
+        [s->window setContentSize:NSMakeSize(d_width, d_height)];
+        [s->window setContentAspectRatio:s->current_video_size];
+        [s->window center];
+
+        if(flags & VOFLAG_HIDDEN) {
+            [s->window orderOut:nil];
+        } else {
+            [s->window makeKeyAndOrderFront:nil];
+            [NSApp activateIgnoringOtherApps:YES];
+        }
+
+        if(flags & VOFLAG_FULLSCREEN)
+            vo_cocoa_fullscreen(ctx->vo);
+    } else {
+        if(! (vo_fs || s->current_video_size.width == s->previous_video_size.width &&
+                       s->current_video_size.height == s->previous_video_size.height) ){
+            // only if we are not in fullscreen or the video size did change
+            // we actually resize the window and set a new aspect ratio
+            [s->window setContentSize:NSMakeSize(d_width, d_height) keepCentered:YES];
+            [s->window setContentAspectRatio: s->current_video_size];
+        }
+    }
+
+    resize_window(ctx->vo);
+
+    if(s->window_title)
+        [s->window_title release];
+
+    s->window_title = [[NSString alloc] initWithUTF8String:title_from_vo_and_title(ctx->vo,title)];
+    [s->window setTitle: s->window_title];
+
+    return SET_WINDOW_OK;
+}
+
+void vo_cocoa_swap_buffers()
+{
+    [s->glContext flushBuffer];
+}
+
+int vo_cocoa_check_events(struct vo *vo)
+{
+    //update activity every 30 seconds to prevent
+    //screensaver from starting up.
+    int curTime = TickCount()/60;
+    if(curTime - s->last_screensaver_update >= 30 || s->last_screensaver_update == 0)
+    {
+        UpdateSystemActivity(UsrActivity);
+        s->last_screensaver_update = curTime;
+    }
+
+    NSEvent *event;
+    event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:nil
+                   inMode:NSEventTrackingRunLoopMode dequeue:YES];
+    if (event == nil)
+        return 0;
+    l_vo = vo;
+    [NSApp sendEvent:event];
+    l_vo = nil;
+
+    if(s->did_resize){
+        s->did_resize = NO;
+        resize_window(vo);
+        return VO_EVENT_RESIZE;
+    }
+#ifndef CONFIG_SDL
+    if ([event type] == NSAppKitDefined
+            && [event subtype] == NSApplicationActivatedEventType) {
+        [s->window makeMainWindow];
+        [s->window makeKeyAndOrderFront:nil];
+    }
+#endif
+    return 0;
+}
+
+void vo_cocoa_fullscreen(struct vo *vo)
+{
+    [s->window fullscreen];
+    resize_window(vo);
+}
+
+void create_menu()
+{
+    NSMenu *menu;
+    NSMenuItem *menuItem;
+
+    menu = [[NSMenu new] autorelease];
+    menuItem = [[NSMenuItem new] autorelease];
+    [menu addItem: menuItem];
+    [NSApp setMainMenu: menu];
+
+    menu = [[NSMenu alloc] initWithTitle:@"Movie"];
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Half Size" action:@selector(halfSize) keyEquivalent:@"0"]; [menu addItem:menuItem];
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Normal Size" action:@selector(normalSize) keyEquivalent:@"1"]; [menu addItem:menuItem];
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Double Size" action:@selector(doubleSize) keyEquivalent:@"2"]; [menu addItem:menuItem];
+
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Movie" action:nil keyEquivalent:@""];
+    [menuItem setSubmenu:menu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    [menu release];
+    [menuItem release];
+}
+
+@implementation GLMPlayerWindow
+@synthesize _tmp_frame;
+
+- (void)windowDidResize:(NSNotification *) notification
+{
+    if(l_vo)
+        s->did_resize = YES;
+}
+
+- (void) fullscreen
+{
+    if(!vo_fs){
+        self._tmp_frame = [self frame];
+        [self setHasShadow:NO];
+        [self setStyleMask:s->fullscreen_mask];
+        [self setFrame:s->screen_frame display:YES animate:NO];
+        [self setLevel:NSNormalWindowLevel + 1];
+        [NSApp setPresentationOptions:NSApplicationPresentationHideDock|NSApplicationPresentationHideMenuBar];
+        CGDisplayHideCursor(kCGDirectMainDisplay);
+        vo_fs = VO_TRUE;
+    } else {
+        [self setHasShadow:YES];
+        [self setStyleMask:s->windowed_mask];
+        [self setTitle:s->window_title];
+        [self setFrame:self._tmp_frame display:YES animate:NO];
+        [self setContentAspectRatio:s->current_video_size];
+        [self setLevel:NSNormalWindowLevel];
+        [NSApp setPresentationOptions:NSApplicationPresentationDefault];
+        CGDisplayShowCursor(kCGDirectMainDisplay);
+        vo_fs = VO_FALSE;
+    }
+}
+
+- (BOOL) canBecomeMainWindow { return YES; }
+- (BOOL) canBecomeKeyWindow { return YES; }
+- (BOOL) acceptsFirstResponder { return YES; }
+- (BOOL) becomeFirstResponder { return YES; }
+- (BOOL) resignFirstResponder { return YES; }
+- (BOOL) windowShouldClose:(id)sender
+{
+    mplayer_put_key(l_vo->key_fifo, KEY_CLOSE_WIN);
+    // We have to wait for MPlayer to handle this,
+    // otherwise we are in trouble if the
+    // KEY_CLOSE_WIN handler is disabled
+    return NO;
+}
+
+- (void) handleQuitEvent:(NSAppleEventDescriptor*)e withReplyEvent:(NSAppleEventDescriptor*)r
+{
+    mplayer_put_key(l_vo->key_fifo, KEY_CLOSE_WIN);
+}
+
+- (void) keyDown:(NSEvent *)theEvent
+{
+    int key = convert_key([theEvent keyCode], *[[theEvent characters] UTF8String]);
+    if (key != -1) {
+        if([theEvent modifierFlags] & NSShiftKeyMask)
+            key |= KEY_MODIFIER_SHIFT;
+        if([theEvent modifierFlags] & NSControlKeyMask)
+            key |= KEY_MODIFIER_CTRL;
+        if(([theEvent modifierFlags] & NSLeftAlternateKeyMask) == NSLeftAlternateKeyMask)
+            key |= KEY_MODIFIER_ALT;
+        if([theEvent modifierFlags] & NSCommandKeyMask)
+            key |= KEY_MODIFIER_META;
+        mplayer_put_key(l_vo->key_fifo, key);
+    }
+}
+
+- (void) mouseDragged:(NSEvent *)theEvent
+{
+    [self mouseEvent: theEvent];
+}
+
+- (void) mouseDown:(NSEvent *)theEvent
+{
+    [self mouseEvent: theEvent];
+}
+
+- (void) mouseUp:(NSEvent *)theEvent
+{
+    [self mouseEvent: theEvent];
+}
+
+- (void) rightMouseDown:(NSEvent *)theEvent
+{
+    [self mouseEvent: theEvent];
+}
+
+- (void) rightMouseUp:(NSEvent *)theEvent
+{
+    [self mouseEvent: theEvent];
+}
+
+- (void) otherMouseDown: (NSEvent *) theEvent
+{
+    [self mouseEvent: theEvent];
+}
+
+- (void) otherMouseUp: (NSEvent *) theEvent
+{
+    [self mouseEvent: theEvent];
+}
+
+- (void) scrollWheel: (NSEvent *) theEvent
+{
+    if([theEvent deltaY] > 0)
+        mplayer_put_key(l_vo->key_fifo, MOUSE_BTN3);
+    else
+        mplayer_put_key(l_vo->key_fifo, MOUSE_BTN4);
+}
+
+- (void) mouseEvent: (NSEvent *) theEvent
+{
+    if ( [theEvent buttonNumber] >= 0 && [theEvent buttonNumber] <= 9 )
+    {
+        int buttonNumber = [theEvent buttonNumber];
+        // Fix to mplayer defined button order: left, middle, right
+        if (buttonNumber == 1)
+            buttonNumber = 2;
+        else if (buttonNumber == 2)
+            buttonNumber = 1;
+        switch([theEvent type])
+        {
+            case NSLeftMouseDown:
+                break;
+            case NSRightMouseDown:
+            case NSOtherMouseDown:
+                mplayer_put_key(l_vo->key_fifo, (MOUSE_BTN0 + buttonNumber) | MP_KEY_DOWN);
+                break;
+            case NSLeftMouseUp:
+                break;
+            case NSRightMouseUp:
+            case NSOtherMouseUp:
+                mplayer_put_key(l_vo->key_fifo, MOUSE_BTN0 + buttonNumber);
+                break;
+        }
+    }
+}
+
+- (void) applicationWillBecomeActive:(NSNotification *)aNotification
+{
+    if(vo_fs){
+        [s->window setLevel:NSNormalWindowLevel + 1];
+        [NSApp setPresentationOptions:NSApplicationPresentationHideDock|NSApplicationPresentationHideMenuBar];
+        [s->window makeKeyAndOrderFront:nil];
+        [NSApp activateIgnoringOtherApps: YES];
+    }
+}
+
+- (void) applicationWillResignActive:(NSNotification *)aNotification
+{
+    if(vo_fs){
+        [s->window setLevel:NSNormalWindowLevel];
+        [NSApp setPresentationOptions:NSApplicationPresentationDefault];
+    }
+}
+
+- (void)applicationDidFinishLaunching:(NSNotification*)notification
+{
+	// Install an event handler so the Quit menu entry works
+	// The proper way using NSApp setDelegate: and
+	// applicationShouldTerminate: does not work,
+	// probably NSApplication never installs its handler.
+	[[NSAppleEventManager sharedAppleEventManager]
+		setEventHandler:self
+		andSelector:@selector(handleQuitEvent:withReplyEvent:)
+		forEventClass:kCoreEventClass
+		andEventID:kAEQuitApplication];
+}
+
+- (void) normalSize
+{
+    if(!vo_fs) {
+        [self setContentSize:s->current_video_size keepCentered:YES];
+    }
+}
+
+- (void) halfSize { [self mulSize:0.5f];}
+
+- (void) doubleSize { [self mulSize:2.0f];}
+
+- (void) mulSize:(float)multiplier
+{
+    if(!vo_fs) {
+        NSSize size = [[self contentView] frame].size;
+        size.width  = s->current_video_size.width  * (multiplier);
+        size.height = s->current_video_size.height * (multiplier);
+        [self setContentSize:size keepCentered:YES];
+    }
+}
+
+- (void) setContentSize:(NSSize)ns keepCentered:(BOOL)keepCentered
+{
+    if(keepCentered){
+        NSRect nf = [self frame];
+        NSRect vf = [[self screen] visibleFrame];
+        int title_height = nf.size.height - [[self contentView] bounds].size.height;
+        double ratio = (double)ns.width / (double)ns.height;
+
+        // clip the new size to the visibleFrame's size if needed
+        if(ns.width > vf.size.width || ns.height + title_height > vf.size.height) {
+            ns = vf.size;
+            ns.height -= title_height; // make space for the title bar
+
+            if(ns.width > ns.height){
+                ns.height = ((double)ns.width * 1/ratio + 0.5);
+            } else {
+                ns.width = ((double)ns.height * ratio + 0.5);
+            }
+        }
+
+        int dw = nf.size.width - ns.width;
+        int dh = nf.size.height - ns.height - title_height;
+
+        nf.origin.x += dw / 2;
+        nf.origin.y += dh / 2;
+
+        [self setFrame: NSMakeRect(nf.origin.x, nf.origin.y, ns.width, ns.height + title_height) display:YES animate:NO];
+    } else {
+        [self setContentSize:ns];
+    }
+}
+@end
+
+@implementation GLMPlayerOpenGLView
+- (void)drawRect: (NSRect)rect
+{
+    [[NSColor clearColor] set];
+    NSRectFill([self bounds]);
+}
+@end
diff --git a/libvo/gl_common.c b/libvo/gl_common.c
index bbcbeb2..9683140 100644
--- a/libvo/gl_common.c
+++ b/libvo/gl_common.c
@@ -1549,6 +1549,46 @@ void glDrawTex(GL *gl, GLfloat x, GLfloat y, GLfloat w, GLfloat h,
     gl->End();
 }
 
+#ifdef CONFIG_GL_COCOA
+#include "cocoa_common.h"
+static int create_window_cocoa(struct MPGLContext *ctx, uint32_t d_width,
+                               uint32_t d_height, uint32_t flags,
+                               const char *title)
+{
+    return vo_cocoa_create_window(ctx, d_width, d_height, flags, title);
+}
+static int setGlWindow_cocoa(MPGLContext *ctx)
+{
+    vo_cocoa_change_attributes(ctx);
+    getFunctions(ctx->gl, (void *)getdladdr, NULL);
+    return SET_WINDOW_OK;
+}
+
+static void releaseGlContext_cocoa(MPGLContext *ctx)
+{
+}
+
+static void swapGlBuffers_cocoa(MPGLContext *ctx)
+{
+    vo_cocoa_swap_buffers();
+}
+
+static int cocoa_check_events(struct vo *vo)
+{
+    return vo_cocoa_check_events(vo);
+}
+
+static void cocoa_update_xinerama_info(struct vo *vo)
+{
+    vo_cocoa_update_xinerama_info(vo);
+}
+
+static void cocoa_fullscreen(struct vo *vo)
+{
+    vo_cocoa_fullscreen(vo);
+}
+#endif
+
 #ifdef CONFIG_GL_WIN32
 #include "w32_common.h"
 
@@ -1921,6 +1961,9 @@ MPGLContext *init_mpglcontext(enum MPGLType type, struct vo *vo)
 {
     MPGLContext *ctx;
     if (type == GLTYPE_AUTO) {
+        ctx = init_mpglcontext(GLTYPE_COCOA, vo);
+        if (ctx)
+            return ctx;
         ctx = init_mpglcontext(GLTYPE_W32, vo);
         if (ctx)
             return ctx;
@@ -1934,6 +1977,19 @@ MPGLContext *init_mpglcontext(enum MPGLType type, struct vo *vo)
     ctx->type = type;
     ctx->vo = vo;
     switch (ctx->type) {
+#ifdef CONFIG_GL_COCOA
+    case GLTYPE_COCOA:
+        ctx->create_window = create_window_cocoa;
+        ctx->setGlWindow = setGlWindow_cocoa;
+        ctx->releaseGlContext = releaseGlContext_cocoa;
+        ctx->swapGlBuffers = swapGlBuffers_cocoa;
+        ctx->check_events = cocoa_check_events;
+        ctx->update_xinerama_info = cocoa_update_xinerama_info;
+        ctx->fullscreen = cocoa_fullscreen;
+        if (vo_cocoa_init(vo))
+            return ctx;
+        break;
+#endif
 #ifdef CONFIG_GL_WIN32
     case GLTYPE_W32:
         ctx->create_window = create_window_w32;
@@ -1992,6 +2048,11 @@ void uninit_mpglcontext(MPGLContext *ctx)
         return;
     ctx->releaseGlContext(ctx);
     switch (ctx->type) {
+#ifdef CONFIG_GL_COCOA
+    case GLTYPE_COCOA:
+        vo_cocoa_uninit(ctx->vo);
+        break;
+#endif
 #ifdef CONFIG_GL_WIN32
     case GLTYPE_W32:
         vo_w32_uninit();
diff --git a/libvo/gl_common.h b/libvo/gl_common.h
index a562484..b2ea406 100644
--- a/libvo/gl_common.h
+++ b/libvo/gl_common.h
@@ -357,6 +357,7 @@ void glDisable3D(GL *gl, int type);
 
 enum MPGLType {
     GLTYPE_AUTO,
+    GLTYPE_COCOA,
     GLTYPE_W32,
     GLTYPE_X11,
     GLTYPE_SDL,
-- 
1.7.6

